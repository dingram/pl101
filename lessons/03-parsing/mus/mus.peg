{
	var tempo = 60;
	var tempo_base = 4;

	var durFromLen = function (len) {
		return (60000 * tempo_base) / (len * tempo);
	}

	var flatten = function (array){
			var flat = [];
			for (var i = 0, l = array.length; i < l; i++){
					var type = Object.prototype.toString.call(array[i]).split(' ').pop().split(']').shift().toLowerCase();
					if (type) { flat = flat.concat(/^(array|collection|arguments|object)$/.test(type) ? flatten(array[i]) : array[i]); }
			}
			return flat;
	}

	var pargen = function(input, dur) {
		var par = create_empty_par(input.length);
		par = fill_par(par, dur, input);
		return par;
	};

	var create_empty_par = function(len) {
		if (len <= 1) {
			return {};
		} else {
			// bias to heavy right -- swap ceil/floor for heavy left
			return { tag: 'par', left: create_empty_par(Math.floor(len/2)), right: create_empty_par(Math.ceil(len/2)) };
		}
	};

	var fill_par = function(par, dur, notes) {
		if (par === null || !('tag' in par)) {
			par = {tag: 'note', pitch: notes.shift(), dur: dur};
		} else {
			par.left = fill_par(par.left, dur, notes);
			par.right = fill_par(par.right, dur, notes);
		}
		return par;
	};
}

start =
	ws* n:notelist ws* { return n; }

notelist =
	tempo ws+ l:notelist
		{ /* do not return tempo objects */ return l; }
	/ n:noteitem ws+ l:notelist
		{ return {tag:'seq', left:n, right: l} }
	/ noteitem

tempo =
	'tempo' ws+ b:int ws* '=' ws* t:int
		{ tempo_base = b; tempo = t; return {tag: 'tempo', base:b, tempo:t}; }
	/ 'tempo' ws+ t:int
		{ tempo_base = 4; tempo = t; return {tag: 'tempo', base:4, tempo:t}; }

noteitem =
	note
	/ rest
	/ extpargroup
	/ pargroup
	/ repeatgroup

rest =
	rest_dur
	/ rest_len

rest_len =
	'r' ':'? len:int
		{ return { tag: 'rest', dur: durFromLen(len) }; }

rest_dur =
	'r/' dur:float
		{ return { tag: 'rest', dur: dur }; }

note =
	note_dur
	/ note_len

note_len =
	pitch:pitch ':' len:length
		{ return { tag: 'note', pitch: pitch, dur: durFromLen(len) }; }

note_dur =
	pitch:pitch '/' dur:float
		{ return { tag: 'note', pitch: pitch, dur: dur }; }

pitch = p:([a-g][#b]*[0-9])
	{ return flatten(p).join(''); }

length =
	n:power_ii '...'
		{ return parseInt(n, 10) * (1 + 0.5 + 0.25 + 0.125); }
	/ n:power_ii '..'
		{ return parseInt(n, 10) * (1 + 0.5 + 0.25); }
	/ n:power_ii '.'
		{ return parseInt(n, 10) * (1 + 0.5); }
	/ n:power_ii
		{ return parseInt(n, 10); }

power_ii = '1' / '2' / '4' / '8' / '16' / '32' / '64' / '128'


pargroup =
	p:parblock ':' len:int
		{
			return pargen(p, durFromLen(len));
		}
	/ p:parblock '/' dur:float
		{
			return pargen(p, dur);
		}

parblock = '<' ws* l:parlist ws* '>' { return l; }

parlist =
	p:pitch ws+ l:parlist
		{ return [p].concat(l); }
	/ p:pitch
		{ return [p]; }

extpargroup = '<<' ws* l:extparlist ws* '>>' { return l; }

extparlist =
        s:seqgroup ws* l:extparlist
		{ return {tag:'par', left: s, right: l} }
        / seqgroup
	/ n:noteitem ws+ l:extparlist
		{ return {tag:'par', left: n, right: l} }
	/ noteitem

seqgroup = '{' ws* s:notelist ws* '}'
		{ return s; }

repeatgroup =
	l:repeatblock ws* '(' n:int ')'
		{ return {tag: 'repeat', section: l, count: n}; }
	/ l:repeatblock
		{ return {tag: 'repeat', section: l, count: 2}; }

repeatblock = '|:' ws* l:notelist ws* ':|' { return l; }



float = x:int ( "." y:zint )? { if (typeof y != 'undefined') return parseFloat(x+'.'+y); else return x; }
int = x:([1-9][0-9]*) { x = flatten(x).join(''); return parseInt(x, 10); }
zint = x:([0-9]+) { flatten(x).join(''); return parseInt(x, 10); }

ws = 
	[ \t\n\r]+
